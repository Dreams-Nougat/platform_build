Revision: 0ae75c3012eb6ddb62ebd0dd7c7edfe98c85a6a9
Patch-set: 2
File: /COMMIT_MSG

14
Thu Mar 26 23:48:34 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: a37b02ac_290c35bf
Bytes: 155
by default, yes, but there's no actual requirement that you have a guard page. http://pubs.opengroup.org/stage7tc1/functions/pthread_attr_getguardsize.html

14
Thu Mar 26 23:50:45 2015 +0000
Author: Nick Kralevich <1003966@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a37b02ac_290c35bf
UUID: 63758ab8_4d4c1d4f
Bytes: 75
Can bionic ensure there's always a guard page? This is pretty important....

14
Thu Mar 26 23:55:20 2015 +0000
Author: Elliott Hughes <1003224@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 63758ab8_4d4c1d4f
UUID: 43d246e8_3761370e
Bytes: 458
POSIX says no: "If guardsize is zero, a guard area shall not be provided for threads created with attr."

but that's not your real enemy. your real enemy is pthread_attr_setstack (http://pubs.opengroup.org/stage7tc1/functions/pthread_attr_getstack.html#). in that case, the caller allocated the stack, and we can't go around calling mprotect on memory they gave us. (especially not because they probably sized it deliberately and assume they can use it all.)

14
Thu Mar 26 23:55:28 2015 +0000
Author: Daniel Micay <1069238@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: a37b02ac_290c35bf
UUID: 43d246e8_d7222bcd
Bytes: 287
If you disable the guard page you lose the guarantee that this will trigger a segmentation fault. The one byte probe write can't really cause any additional harm if the guard page is missing though. The thread is going to clobber a bunch of stuff with or without this if you do overflow.

14
Fri Mar 27 00:00:36 2015 +0000
Author: Daniel Micay <1069238@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 43d246e8_d7222bcd
UUID: 63758ab8_0dadc514
Bytes: 499
One way to make exploitation harder even if there's no guard page would be to add weak secondary stack ASLR in Bionic. The problem with that is it can screw over callers with very precisely sized stacks, as they'll have less available than they expect.

Using a single page for ASLR with stacks >= 1M is arguably sane because they could be screwed over by a compiler update if they're that close to the end...

I have a patch doing this but it's pretty sketchy so I didn't have plans to upstream it.

