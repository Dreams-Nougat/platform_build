Revision: f12e849ea7fb7600f5f02b5a57d9990181812dc7
Patch-set: 9
File: tools/apksigner/core/src/com/android/apksigner/core/ApkSignerEngine.java

81:10-81:31
Sun May 08 20:30:54 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 927038c5_99c11b44
Bytes: 178
My expectation while reading this is that I can reuse the engine for subsequent incremental runs on the same input/output APK as long as I do not invoke close(). Is this correct?

81:10-81:31
Sun May 08 20:30:54 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 927038c5_59df031c
Bytes: 432
Now, if all above are "yes", then for incremental runs in the "new" engine, my expectation is that I need to inform of all existing input entries, but for runs in the "reused" engine, I only need to inform of changed input entries.

Regarding output entries, I need to inform of all existing output entries in the "new" engine. In the "reused" engine, I only need to inform if I cannot guarantee they have not been changed, correct?

81:10-81:31
Sun May 08 20:30:54 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 927038c5_b9be5fbb
Bytes: 426
If the answer to the previous comment is "yes", then in the case of an incremental run where 1 file has been added to the input, there would be two possible sequences: one in which I reuse the engine and another in which I would create a new engine. Right? This would allow much better performance in the build system if I can keep the engine object cached. However, even if I cannot, I can still do an incremental run, right?

81:10-81:31
Mon May 09 18:15:25 2016 +0000
Author: Alex Klyubin <1018773@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 927038c5_b9be5fbb
UUID: 12728820_a82073eb
Bytes: 453
I presume you're talking about how this engine would be used in your Gradle/AS pipeline. If so, you're 100% correct. Given that we can't persist the engine across invocations of ./gradlew, the only place there's a chance to use this engine's incremental mode (not to be confused with your pipeline's incremental mode!) is when building in Android Studio. There, it should be possible to preserve the engine's instance across invocations of the pipeline.

81:10-81:31
Mon May 09 20:33:09 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12728820_a82073eb
UUID: 72af4490_58cc1dcf
Bytes: 35
Perfect then. It all makes sense :)

107:9-107:29
Sun May 08 20:30:54 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 927038c5_79e447f3
Bytes: 175
I'm curious about why the engine would ever need this. If I'm doing IN -> OUT, OUT's v2 signature would be a newly computed one, so what is the relevance of IN's v2 signature?

107:9-107:29
Mon May 09 18:15:25 2016 +0000
Author: Alex Klyubin <1018773@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 927038c5_79e447f3
UUID: 12728820_e5b37659
Bytes: 170
Depending on the engine's configuration/impl it may or may not need to preserve: (1) input APK's v2 signatures, and/or (2) input APK's non-v2 blocks in APK Signing Block.

107:9-107:29
Mon May 09 20:33:09 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12728820_e5b37659
UUID: 72af4490_78d1e161
Bytes: 4
Done

127:35-127:49
Sun May 08 20:30:54 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: f2fb3484_0c925759
Bytes: 144
Can it happen that the engine wants to remove a file from the output? For example, what about the CERT.RSA file if you're not signing using RSA.

127:35-127:49
Mon May 09 18:15:25 2016 +0000
Author: Alex Klyubin <1018773@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: f2fb3484_0c925759
UUID: 12728820_e58a9675
Bytes: 253
Yes, that's why you want to use inputJarEntry first, if you can, to avoid outputting an entry which the engine doesn't like. However, the current pipeline in Gradle/AS doesn't offer this luxury.

See Output-only Operation section of class-level Javadoc.

127:35-127:49
Mon May 09 20:33:09 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12728820_e58a9675
UUID: f2fb3484_eca0abb3
Bytes: 4
Done

137:43-137:63
Sun May 08 20:30:54 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 927038c5_19e98bca
Bytes: 172
You don't handle the case in which we update an input entry. You're expecting me to call inputJarEntryRemoved followed by inputJarEntry, right? This is just to make sure :)

137:43-137:63
Mon May 09 18:15:25 2016 +0000
Author: Alex Klyubin <1018773@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 927038c5_19e98bca
UUID: 12728820_65d14662
Bytes: 171
It's up to you. I've now added documentation to input/outputJarEntryAdded to say that it's fine to invoke this without first invoking Removed if you're updating the entry.

137:43-137:63
Mon May 09 20:33:09 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 12728820_65d14662
UUID: 72af4490_98c5d5a2
Bytes: 4
Done

202:9-202:14
Sun May 08 20:30:54 2016 +0000
Author: Paulo Casanova <1104608@85c56323-6fa9-3386-8a01-6480fb634889>
UUID: 927038c5_39eecfd3
Bytes: 298
Does this method imply outputDone() kinda like File's close() implies flush()? Or is it incorrect to do:

try (ApkSignerEngine engine = ...) {
    engine.inputJarEntry()...
    // Do not call outputDone()
}

If calling close still requires a call to outputDone(), could you add that to the javadoc?

202:9-202:14
Mon May 09 18:15:25 2016 +0000
Author: Alex Klyubin <1018773@85c56323-6fa9-3386-8a01-6480fb634889>
Parent: 927038c5_39eecfd3
UUID: 12728820_65b78604
Bytes: 39
I've now clarified this in the Javadoc.

