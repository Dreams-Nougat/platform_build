#!/usr/bin/env python

import ConfigParser
import sys

GENERATED = '''
/*
 * THIS IS AN AUTOGENERATED FILE! DO NOT MODIFY
 */
'''

INCLUDE = '#include <private/android_filesystem_config.h>'

DEFINE_NO_DIRS = '#define NO_ANDROID_FILESYSTEM_CONFIG_DEVICE_DIRS'
DEFINE_NO_FILES = '#define NO_ANDROID_FILESYSTEM_CONFIG_DEVICE_FILES'

DEFAULT_WARNING = '#warning No device-supplied android_filesystem_config.h, using empty default.'

NO_ANDROID_FILESYSTEM_CONFIG_DEVICE_DIRS_ENTRY = '{ 00000, AID_ROOT,      AID_ROOT,      0, "system/etc/fs_config_dirs" },'
NO_ANDROID_FILESYSTEM_CONFIG_DEVICE_FILES_ENTRY = '{ 00000, AID_ROOT,      AID_ROOT,      0, "system/etc/fs_config_files" },'

IFDEF_ANDROID_FILESYSTEM_CONFIG_DEVICE_DIRS = '#ifdef NO_ANDROID_FILESYSTEM_CONFIG_DEVICE_DIRS'
ENDIF = '#endif'

OPEN_FILE_STRUCT = 'static const struct fs_path_config android_device_files[] = {'
OPEN_DIR_STRUCT = 'static const struct fs_path_config android_device_dirs[] = {'
CLOSE_FILE_STRUCT = '};'

def parse(config, files, dirs):

        for s in config.sections():

            mode = config.get(s, 'mode')
            user = config.get(s, 'user')
            group = config.get(s, 'group')
            caps = config.get(s, 'caps')

            if not mode:
                raise Exception('Found specified but unset "mode" for: \"' + s + '"')

            if not user:
                raise Exception('Found specified but unset "user" for: \"' + s + '"')

            if not group:
                raise Exception('Found specified but unset "group" for: \"' + s + '"')

            if not caps:
                raise Exception('Found specified but unset "caps" for: \"' + s + '"')

            caps = caps.split()

            tmp = []
            for x in caps:
                is_num = False
                for base in [2, 8, 10, 16]:
                    try:
                        int(x, base)
                        is_num = True
                    except ValueError:
                        pass

                    if is_num:
                        break

                if not is_num:
                    tmp.append('(1ULL << CAP_' + x.upper() + ')')
                else:
                    tmp.append('(' + x + ')')

            caps = tmp

            path = '"' + s + '"'

            if len(mode) == 3:
                mode = '0' + mode

            try:
                int(mode, 8)
            except:
                raise Exception('Mode must be octal characters, got: "' + mode + '"')

            if len(mode) != 4:
                raise Exception('Mode must be 3 or 4 characters, got: "' + mode + '"')


            caps = '|'.join(caps)

            x =  [ mode, user, group, caps, s ]
            if s[-1] == '/':
                dirs.append(x)
            else:
                files.append(x)

def generate(files, dirs):
    print GENERATED
    print INCLUDE
    print

    are_dirs = len(dirs) > 0
    are_files = len(files) > 0

    if not are_dirs:
        print DEFINE_NO_DIRS

    if not are_files:
        print DEFINE_NO_FILES

    if not are_files and not are_dirs:
        print DEFAULT_WARNING
        return

    if are_files:
        print OPEN_FILE_STRUCT
        for f in files:
            f[4] = '"' + f[4] + '"'
            f = '{ ' + '    ,'.join(f) + ' },'
            print '    ' + f

        if not are_dirs:
            print IFDEF_ANDROID_FILESYSTEM_CONFIG_DEVICE_DIRS
            print '    ' + NO_ANDROID_FILESYSTEM_CONFIG_DEVICE_DIRS_ENTRY
            print ENDIF
        print CLOSE_FILE_STRUCT

    if are_dirs:
        print OPEN_DIR_STRUCT
        for d in dirs:
            f[4] = '"' + f[4] + '"'
            d = '{ ' + '    ,'.join(d) + ' },'
            print '    ' + d

        print CLOSE_FILE_STRUCT

def file_key(x):

    # Wrapper class for custom prefix matching strings
    class S(object):
        def __init__(self, str):

            self.orig = str
            self.is_prefix = str[-1] == '*'
            if self.is_prefix:
                self.str = str[:-1]
            else:
                self.str = str

        def __lt__(self, other):

            # if were both suffixed the smallest string
            # is 'bigger'
            if self.is_prefix and other.is_prefix:
                b = len(self.str) > len(other.str)
            # If I am an the suffix match, im bigger
            elif self.is_prefix:
                b = False
            # If other is the suffix match, he's bigger
            elif other.is_prefix:
                b = True
            # Alphabetical
            else:
                b = self.str < other.str
            return b

    return S(x[4])

def main():

    files = []
    dirs = []

    for x in sys.argv[1:]:
        config = ConfigParser.ConfigParser()
        config.read(x)
        parse(config, files, dirs)

    files.sort(key=file_key)
    generate(files, dirs)

if __name__ == '__main__':
    main()
